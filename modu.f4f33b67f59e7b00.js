"use strict";(("undefined"!=typeof self?self:this).webpackChunk_polkadot_apps=("undefined"!=typeof self?self:this).webpackChunk_polkadot_apps||[]).push([[5512],{9954:(e,r,o)=>{o.d(r,{hY:()=>t.h,LX:()=>l,Ps:()=>u,t_:()=>p,BL:()=>d});var n=o(33323),t=o(48095),s=o(40767),i=function(e,r,o,n){return new(o||(o=Promise))((function(t,s){function i(e){try{a(n.next(e))}catch(e){s(e)}}function c(e){try{a(n.throw(e))}catch(e){s(e)}}function a(e){var r;e.done?t(e.value):(r=e.value,r instanceof o?r:new o((function(e){e(r)}))).then(i,c)}a((n=n.apply(e,r||[])).next())}))},c=o(36753),a=function(e,r,o,n){return new(o||(o=Promise))((function(t,s){function i(e){try{a(n.next(e))}catch(e){s(e)}}function c(e){try{a(n.throw(e))}catch(e){s(e)}}function a(e){var r;e.done?t(e.value):(r=e.value,r instanceof o?r:new o((function(e){e(r)}))).then(i,c)}a((n=n.apply(e,r||[])).next())}))};class l extends Error{constructor(e){super(e)}}class u extends Error{constructor(){super("JSON-RPC request is malformed")}}class p extends Error{constructor(){super("JSON-RPC requests queue is full")}}function d(e,r){let o;const d={},f={name:null},h={printError:!0};let w=new Map;const m=(()=>a(this,void 0,void 0,(function*(){const o={onWasmPanic:e=>{if(d.error=new l(e),h.printError){console.error("Smoldot has panicked"+(f.name?" while executing task `"+f.name+"`":"")+". This is a bug in smoldot. Please open an issue at https://github.com/smol-dot/smoldot/issues with the following message:\n"+e);for(const e of Array.from(w.values())){for(const r of e.jsonRpcResponsesPromises)r.reject(d.error);e.jsonRpcResponsesPromises=[]}}},logCallback:(r,o,n)=>{e.logCallback(r,o,n)},wasmModule:yield e.wasmModule,jsonRpcResponsesNonEmptyCallback:e=>{const r=w.get(e).jsonRpcResponsesPromises;for(;0!==r.length;)r.shift().resolve()},currentTaskCallback:e=>{f.name=e},cpuRateLimit:e.cpuRateLimit,maxLogLevel:e.maxLogLevel};return yield function(e,r){return i(this,void 0,void 0,(function*(){let o;const n=new Array,c={value:null},a=Object.assign({bufferIndices:n,connect:r.connect,onPanic:r=>{throw o(),e.onWasmPanic(r),new Error},advanceExecutionReadyCallback:()=>{c.value&&c.value(),c.value=null}},e),l={envVars:[],getRandomValues:r.getRandomValues,performanceNow:r.performanceNow,onProcExit:r=>{throw o(),e.onWasmPanic(`proc_exit called: ${r}`),new Error}},{imports:u,killAll:p}=(0,t.Z)(a);o=p;const d=yield WebAssembly.instantiate(e.wasmModule,{smoldot:u,wasi_snapshot_preview1:(0,s.Z)(l)});return a.instance=d,l.instance=d,d.exports.init(e.maxLogLevel),(()=>{i(this,void 0,void 0,(function*(){let o=0,n=e.cpuRateLimit;isNaN(n)&&(n=1),n>1&&(n=1),n<0&&(n=0);const t={value:!1},[s,i]=r.registerShouldPeriodicallyYield((e=>{t.value=e}));t.value=s;let a=r.performanceNow();for(;;){const e=new Promise((e=>c.value=e));if(0===d.exports.advance_execution()){i();break}const s=r.performanceNow(),l=s-a;a=s,o+=l*(1/n-1),o>(t?5:1e3)&&(o>2147483646&&(o=2147483646),yield new Promise((e=>setTimeout(e,o))),o=0),yield e;const u=r.performanceNow();o-=u-a,o<0&&(o=0),a=u}}))})(),[d,n]}))}(o,r)})))();function v(e){return a(this,void 0,void 0,(function*(){return o.initialized?e(o.instance,o.bufferIndices):o.promise.then((([r,o])=>e(r,o)))}))}return o={initialized:!1,promise:m.then((([e,r])=>(o={initialized:!0,instance:e,bufferIndices:r},[e,r])))},{request:(e,r)=>{if(!o.initialized)throw new Error("Internal error");if(d.error)throw d.error;let n;try{o.bufferIndices[0]=(new TextEncoder).encode(e),n=o.instance.exports.json_rpc_send(0,r)>>>0}catch(e){throw console.assert(d.error),d.error}switch(n){case 0:break;case 1:throw new u;case 2:throw new p;default:throw new Error("Internal error: unknown json_rpc_send error code: "+n)}},nextJsonRpcResponse:e=>a(this,void 0,void 0,(function*(){if(!o.initialized)throw new Error("Internal error");for(;;){if(d.error)throw d.error;try{const r=new Uint8Array(o.instance.exports.memory.buffer),t=o.instance.exports.json_rpc_responses_peek(e)>>>0,s=n.nm(r,t)>>>0,i=n.nm(r,t+4)>>>0;if(0!==i){const t=n.yV(r,s,i);return o.instance.exports.json_rpc_responses_pop(e),t}}catch(e){throw console.assert(d.error),d.error}yield new Promise(((r,o)=>{w.get(e).jsonRpcResponsesPromises.push({resolve:()=>r(void 0),reject:o})}))}})),addChain:(e,r,o,t)=>v(((s,i)=>{if(d.error)throw d.error;try{i[0]=(new TextEncoder).encode(e),i[1]=(new TextEncoder).encode(r);const c=new Uint8Array(4*o.length);for(let e=0;e<o.length;++e)n.v7(c,4*e,o[e]);i[2]=c;const a=s.exports.add_chain(0,1,t?0:1,2);if(delete i[0],delete i[1],delete i[2],0!=s.exports.chain_is_ok(a))return console.assert(!w.has(a)),w.set(a,{jsonRpcResponsesPromises:new Array}),{success:!0,chainId:a};{const e=s.exports.chain_error_len(a)>>>0,r=s.exports.chain_error_ptr(a)>>>0,o=n.yV(new Uint8Array(s.exports.memory.buffer),r,e);return s.exports.remove_chain(a),{success:!1,error:o}}}catch(e){throw console.assert(d.error),d.error}})),removeChain:e=>{if(!o.initialized)throw new Error("Internal error");if(d.error)throw d.error;console.assert(w.has(e));for(const{reject:r}of w.get(e).jsonRpcResponsesPromises)r(new c.A_);w.delete(e);try{o.instance.exports.remove_chain(e)}catch(e){throw console.assert(d.error),d.error}},startShutdown:()=>v((e=>{if(!d.error)try{h.printError=!1,e.exports.start_shutdown()}catch(e){}}))}}}}]);