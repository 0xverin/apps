"use strict";(("undefined"!=typeof self?self:this).webpackChunk_polkadot_apps=("undefined"!=typeof self?self:this).webpackChunk_polkadot_apps||[]).push([[1710],{9864:(e,n,t)=>{t.r(n),t.d(n,{AddChainError:()=>a.iA,AlreadyDestroyedError:()=>a.A_,CrashError:()=>a.LX,JsonRpcDisabledError:()=>a.BU,QueueFullError:()=>a.t_,startWithBytecode:()=>s});var o=t(18835),a=t(37362),r=function(e,n,t,o){return new(t||(t=Promise))((function(a,r){function s(e){try{l(o.next(e))}catch(e){r(e)}}function i(e){try{l(o.throw(e))}catch(e){r(e)}}function l(e){var n;e.done?a(e.value):(n=e.value,n instanceof t?n:new t((function(e){e(n)}))).then(s,i)}l((o=o.apply(e,n||[])).next())}))};function s(e){return e.forbidTcp=!0,(0,o.B)(e,e.bytecode,{performanceNow:()=>performance.now(),getRandomValues:e=>{const n=globalThis.crypto;if(!n)throw new Error("randomness not available");if(e.buffer instanceof ArrayBuffer)n.getRandomValues(e);else{const t=new Uint8Array(e.length);n.getRandomValues(t),e.set(t)}},connect:e=>function(e){if("websocket"===e.address.ty){let n;try{n=new WebSocket(e.address.url)}catch(e){n=e instanceof Error?e.toString():"Exception thrown by new WebSocket"}const t={quenedUnreportedBytes:0,nextTimeout:10},o=()=>{if(!(n instanceof WebSocket))return;if(1!=n.readyState)return;const a=n.bufferedAmount;let r=t.quenedUnreportedBytes-a;r<0&&(r=0),t.quenedUnreportedBytes-=r,0!=t.quenedUnreportedBytes&&(setTimeout(o,t.nextTimeout),t.nextTimeout*=2,t.nextTimeout>500&&(t.nextTimeout=500)),0!=r&&e.onWritableBytes(r)};return n instanceof WebSocket?(n.binaryType="arraybuffer",n.onopen=()=>{e.onOpen({type:"single-stream",handshake:"multistream-select-noise-yamux",initialWritableBytes:1048576})},n.onclose=n=>{const t="Error code "+n.code+(n.reason?": "+n.reason:"");e.onConnectionReset(t)},n.onmessage=n=>{e.onMessage(new Uint8Array(n.data))}):setTimeout((()=>{!n||n instanceof WebSocket||(e.onConnectionReset(n),n=null)}),1),{reset:()=>{n instanceof WebSocket&&(n.onopen=null,n.onclose=null,n.onmessage=null,n.onerror=null,n.readyState==WebSocket.OPEN&&n.close()),n=null},send:e=>{n.send(e),0==t.quenedUnreportedBytes&&(t.nextTimeout=10,setTimeout(o,10)),t.quenedUnreportedBytes+=e.length},closeSend:()=>{throw new Error("Wrong connection type")},openOutSubstream:()=>{throw new Error("Wrong connection type")}}}if("webrtc"===e.address.ty){const{targetPort:n,ipVersion:t,targetIp:o,remoteTlsCertificateSha256:a}=e.address;let s;const i=new Map;let l,c;const d=()=>{if(!s)return console.assert(0===i.size&&!l,"substreams exist while pc is undef"),void(s=null);s.onconnectionstatechange=null,s.onnegotiationneeded=null,s.ondatachannel=null;for(const e of Array.from(i.values()))e.channel.onopen=null,e.channel.onerror=null,e.channel.onclose=null,e.channel.onbufferedamountlow=null,e.channel.onmessage=null;i.clear(),l&&(l.onopen=null,l.onerror=null,l.onclose=null,l.onbufferedamountlow=null,l.onmessage=null),l=void 0,s.close()},u=(n,t)=>{const o=n.id;n.binaryType="arraybuffer";let r=!1;n.onopen=()=>{console.assert(!r,"substream opened twice"),r=!0,"first-outbound"===t?(console.assert(0===i.size,"dataChannels not empty when opening"),console.assert(l===n,"handshake substream mismatch"),e.onOpen({type:"multi-stream",handshake:"webrtc",localTlsCertificateSha256:c,remoteTlsCertificateSha256:a})):(console.assert("outbound"!==t||!l,"handshakeDataChannel still defined"),e.onStreamOpened(o,t,65536))},n.onerror=n.onclose=t=>{l!==n||r?l===n?(l.onopen=null,l.onerror=null,l.onclose=null,l.onbufferedamountlow=null,l.onmessage=null,l=void 0):r?e.onStreamReset(o):(d(),e.onConnectionReset("data channel failed to open")):(d(),e.onConnectionReset("handshake data channel failed to open"))},n.onbufferedamountlow=()=>{const n=i.get(o),t=n.bufferedBytes;n.bufferedBytes=0,e.onWritableBytes(t,o)},n.onmessage=n=>{e.onMessage(new Uint8Array(n.data),o)},"first-outbound"!==t?i.set(o,{channel:n,bufferedBytes:0}):l=n};return RTCPeerConnection.generateCertificate({name:"ECDSA",namedCurve:"P-256",hash:"SHA-256"}).then((i=>r(this,void 0,void 0,(function*(){if(null===s)return;let l;if(s=new RTCPeerConnection({certificates:[i]}),i.getFingerprints){for(const{algorithm:e,value:n}of i.getFingerprints())if("sha-256"===e){l=n;break}}else{const e=(yield s.createOffer()).sdp.match(/a(\s*)=(\s*)fingerprint:(\s*)(sha|SHA)-256(\s*)(([a-fA-F0-9]{2}(:)*){32})/);e&&(l=e[6])}void 0!==l?(c=new Uint8Array(32),c.set(l.split(":").map((e=>parseInt(e,16))),0),s.onconnectionstatechange=n=>{"closed"!=s.connectionState&&"disconnected"!=s.connectionState&&"failed"!=s.connectionState||(d(),e.onConnectionReset("WebRTC state transitioned to "+s.connectionState))},s.onnegotiationneeded=e=>r(this,void 0,void 0,(function*(){var e;let r=(yield s.createOffer()).sdp;null===r.match(/^m=application(\s+)(\d+)(\s+)UDP\/DTLS\/SCTP(\s+)webrtc-datachannel$/m)&&console.error("Local offer doesn't contain UDP data channel. WebRTC connections will likely fail. Please report this issue.");const i=null===(e=r.match(/^a=ice-pwd:(.+)$/m))||void 0===e?void 0:e.at(1);void 0===i&&console.error("Failed to set ufrag to pwd. WebRTC connections will likely fail. Please report this issue.");const l="libp2p+webrtc+v1/"+i;r=r.replace(/^a=ice-ufrag.*$/m,"a=ice-ufrag:"+l),r=r.replace(/^a=ice-pwd.*$/m,"a=ice-pwd:"+l),yield s.setLocalDescription({type:"offer",sdp:r});const c=Array.from(a).map((e=>("0"+e.toString(16)).slice(-2).toUpperCase())).join(":"),d="v=0\no=- 0 0 IN IP"+t+" "+o+"\ns=-\nt=0 0\na=ice-lite\nm=application "+String(n)+" UDP/DTLS/SCTP webrtc-datachannel\nc=IN IP"+t+" "+o+"\na=mid:0\na=ice-options:ice2\na=ice-ufrag:"+l+"\na=ice-pwd:"+l+"\na=fingerprint:sha-256 "+c+"\na=setup:passive\na=sctp-port:5000\na=max-message-size:16384\na=candidate:1 1 UDP 1 "+o+" "+String(n)+" typ host\n";yield s.setRemoteDescription({type:"answer",sdp:d})})),s.ondatachannel=({channel:e})=>{u(e,"inbound")},u(s.createDataChannel("",{id:0,negotiated:!0}),"first-outbound")):e.onConnectionReset("Failed to obtain the browser certificate fingerprint")})))),{reset:e=>{if(void 0===e)d();else{const n=i.get(e);n.channel.onopen=null,n.channel.onerror=null,n.channel.onclose=null,n.channel.onbufferedamountlow=null,n.channel.onmessage=null,n.channel.close(),i.delete(e)}},send:(e,n)=>{const t=i.get(n);t.channel.send(e),t.bufferedBytes+=e.length},closeSend:()=>{throw new Error("Wrong connection type")},openOutSubstream:()=>{l?(()=>{r(this,void 0,void 0,(function*(){l&&(e.onStreamOpened(l.id,"outbound",1048576),i.set(l.id,{channel:l,bufferedBytes:0}),l=void 0)}))})():u(s.createDataChannel(""),"outbound")}}}throw new Error}(e)})}}}]);