"use strict";(("undefined"!=typeof self?self:this).webpackChunk_polkadot_apps=("undefined"!=typeof self?self:this).webpackChunk_polkadot_apps||[]).push([[5512],{9954:(e,r,n)=>{n.d(r,{hY:()=>t.h,LX:()=>p,Ps:()=>u,t_:()=>h,BL:()=>f});var o=n(33323),t=n(48095),s=n(40767),i=n(62702);function c(e,r){return n=this,o=void 0,a=function*(){const n=yield r.trustedBase64DecodeAndZlibInflate(i.Z);let o;const c=Object.assign({performanceNow:r.performanceNow,connect:r.connect,onPanic:r=>{throw o(),e.onWasmPanic(r),new Error}},e),a={envVars:[],getRandomValues:r.getRandomValues,onProcExit:r=>{throw o(),e.onWasmPanic(`proc_exit called: ${r}`),new Error}},{imports:l,killAll:p}=(0,t.Z)(c);o=p;const u=(yield WebAssembly.instantiate(n,{smoldot:l,wasi_snapshot_preview1:(0,s.Z)(a)})).instance;return c.instance=u,a.instance=u,u},new((c=void 0)||(c=Promise))((function(e,r){function t(e){try{i(a.next(e))}catch(e){r(e)}}function s(e){try{i(a.throw(e))}catch(e){r(e)}}function i(r){var n;r.done?e(r.value):(n=r.value,n instanceof c?n:new c((function(e){e(n)}))).then(t,s)}i((a=a.apply(n,o||[])).next())}));var n,o,c,a}var a=n(36753),l=function(e,r,n,o){return new(n||(n=Promise))((function(t,s){function i(e){try{a(o.next(e))}catch(e){s(e)}}function c(e){try{a(o.throw(e))}catch(e){s(e)}}function a(e){var r;e.done?t(e.value):(r=e.value,r instanceof n?r:new n((function(e){e(r)}))).then(i,c)}a((o=o.apply(e,r||[])).next())}))};class p extends Error{constructor(e){super(e)}}class u extends Error{constructor(){super("JSON-RPC request is malformed")}}class h extends Error{constructor(){super("JSON-RPC requests queue is full")}}function f(e,r){let n;const t={},s={name:null},i={printError:!0};let f=new Map;const d={onWasmPanic:e=>{if(t.error=new p(e),i.printError){console.error("Smoldot has panicked"+(s.name?" while executing task `"+s.name+"`":"")+". This is a bug in smoldot. Please open an issue at https://github.com/smol-dot/smoldot/issues with the following message:\n"+e);for(const e of Array.from(f.values())){for(const r of e.jsonRpcResponsesPromises)r.reject(t.error);e.jsonRpcResponsesPromises=[]}}},logCallback:(r,n,o)=>{e.logCallback(r,n,o)},jsonRpcResponsesNonEmptyCallback:e=>{const r=f.get(e).jsonRpcResponsesPromises;for(;0!==r.length;)r.shift().resolve()},currentTaskCallback:e=>{s.name=e},cpuRateLimit:e.cpuRateLimit};function m(e){return l(this,void 0,void 0,(function*(){return n.initialized?e(n.instance):n.promise.then((r=>e(r)))}))}return n={initialized:!1,promise:c(d,r).then((o=>{let s=Math.round(4294967295*d.cpuRateLimit);s<0&&(s=0),s>4294967295&&(s=4294967295),Number.isFinite(s)||(s=4294967295);const[i,c]=r.registerShouldPeriodicallyYield((e=>{if(n.initialized&&!t.error)try{n.instance.exports.set_periodically_yield(e?1:0)}catch(e){}}));return o.exports.init(e.maxLogLevel,e.enableCurrentTask?1:0,s,i?1:0),n={initialized:!0,instance:o,unregisterCallback:c},o}))},{request:(e,r)=>{if(!n.initialized)throw new Error("Internal error");if(t.error)throw t.error;let o;try{const t=(new TextEncoder).encode(e),s=n.instance.exports.alloc(t.length)>>>0;new Uint8Array(n.instance.exports.memory.buffer).set(t,s),o=n.instance.exports.json_rpc_send(s,t.length,r)>>>0}catch(e){throw console.assert(t.error),t.error}switch(o){case 0:break;case 1:throw new u;case 2:throw new h;default:throw new Error("Internal error: unknown json_rpc_send error code: "+o)}},nextJsonRpcResponse:e=>l(this,void 0,void 0,(function*(){if(!n.initialized)throw new Error("Internal error");for(;;){if(t.error)throw t.error;try{const r=new Uint8Array(n.instance.exports.memory.buffer),t=n.instance.exports.json_rpc_responses_peek(e)>>>0,s=o.nm(r,t)>>>0,i=o.nm(r,t+4)>>>0;if(0!==i){const t=o.yV(r,s,i);return n.instance.exports.json_rpc_responses_pop(e),t}}catch(e){throw console.assert(t.error),t.error}yield new Promise(((r,n)=>{f.get(e).jsonRpcResponsesPromises.push({resolve:()=>r(void 0),reject:n})}))}})),addChain:(e,r,n,s)=>m((i=>{if(t.error)throw t.error;try{const t=(new TextEncoder).encode(e),c=i.exports.alloc(t.length)>>>0;new Uint8Array(i.exports.memory.buffer).set(t,c);const a=(new TextEncoder).encode(r),l=i.exports.alloc(a.length)>>>0;new Uint8Array(i.exports.memory.buffer).set(a,l);const p=n.length,u=i.exports.alloc(4*p)>>>0;for(let e=0;e<n.length;++e)o.v7(new Uint8Array(i.exports.memory.buffer),u+4*e,n[e]);const h=i.exports.add_chain(c,t.length,l,a.length,s?0:1,u,p);if(0!=i.exports.chain_is_ok(h))return console.assert(!f.has(h)),f.set(h,{jsonRpcResponsesPromises:new Array}),{success:!0,chainId:h};{const e=i.exports.chain_error_len(h)>>>0,r=i.exports.chain_error_ptr(h)>>>0,n=o.yV(new Uint8Array(i.exports.memory.buffer),r,e);return i.exports.remove_chain(h),{success:!1,error:n}}}catch(e){throw console.assert(t.error),t.error}})),removeChain:e=>{if(!n.initialized)throw new Error("Internal error");if(t.error)throw t.error;console.assert(f.has(e));for(const{reject:r}of f.get(e).jsonRpcResponsesPromises)r(new a.A_);f.delete(e);try{n.instance.exports.remove_chain(e)}catch(e){throw console.assert(t.error),t.error}},startShutdown:()=>m((e=>{if(!t.error){n.initialized&&n.unregisterCallback();try{i.printError=!1,e.exports.start_shutdown()}catch(e){}}}))}}}}]);