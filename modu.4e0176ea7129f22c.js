"use strict";(("undefined"!=typeof self?self:this).webpackChunk_polkadot_apps=("undefined"!=typeof self?self:this).webpackChunk_polkadot_apps||[]).push([[8717],{83867:(e,n,t)=>{t.r(n),t.d(n,{AddChainError:()=>o.iA,AlreadyDestroyedError:()=>o.A_,CrashError:()=>o.LX,JsonRpcDisabledError:()=>o.BU,MalformedJsonRpcError:()=>o.Ps,QueueFullError:()=>o.t_,start:()=>c});var o=t(36753),s=t(9954),r=t(53214),a=t(33654),i=t(62702),l=function(e,n,t,o){return new(t||(t=Promise))((function(s,r){function a(e){try{l(o.next(e))}catch(e){r(e)}}function i(e){try{l(o.throw(e))}catch(e){r(e)}}function l(e){var n;e.done?s(e.value):(n=e.value,n instanceof t?n:new t((function(e){e(n)}))).then(a,i)}l((o=o.apply(e,n||[])).next())}))};function c(e){e=e||{};const n=WebAssembly.compile((0,a.rr)((0,r.xl)(i.Z)));return(0,o.BL)(e,n,{registerShouldPeriodicallyYield:e=>{if("undefined"==typeof document)return[!1,()=>{}];const n=()=>e("visible"===document.visibilityState);return document.addEventListener("visibilitychange",n),["visible"===document.visibilityState,()=>{document.removeEventListener("visibilitychange",n)}]},performanceNow:()=>performance.now(),getRandomValues:e=>{const n=globalThis.crypto;if(!n)throw new Error("randomness not available");if(e.buffer instanceof ArrayBuffer)n.getRandomValues(e);else{const t=new Uint8Array(e.length);n.getRandomValues(t),e.set(t)}},connect:n=>function(e,n,t,o,a){const i=e.address.match(/^\/(ip4|ip6|dns4|dns6|dns)\/(.*?)\/tcp\/(.*?)\/(ws|wss|tls\/ws)$/),c=e.address.match(/^\/(ip4|ip6)\/(.*?)\/udp\/(.*?)\/webrtc-direct\/certhash\/(.*?)$/);if(null!=i){const r="ws"==i[4]?"ws":"wss";if("ws"==r&&n||"ws"==r&&"localhost"!=i[2]&&"127.0.0.1"!=i[2]&&t||"wss"==r&&o)throw new s.hY("Connection type not allowed");const a="ip6"==i[1]?r+"://["+i[2]+"]:"+i[3]:r+"://"+i[2]+":"+i[3],l=new WebSocket(a);l.binaryType="arraybuffer";const c={quenedUnreportedBytes:0,nextTimeout:10},d=()=>{if(1!=l.readyState)return;const n=l.bufferedAmount;let t=c.quenedUnreportedBytes-n;t<0&&(t=0),c.quenedUnreportedBytes-=t,0!=c.quenedUnreportedBytes&&(setTimeout(d,c.nextTimeout),c.nextTimeout*=2,c.nextTimeout>500&&(c.nextTimeout=500)),0!=t&&e.onWritableBytes(t)};return l.onopen=()=>{e.onOpen({type:"single-stream",handshake:"multistream-select-noise-yamux",initialWritableBytes:1048576,writeClosable:!1})},l.onclose=n=>{const t="Error code "+n.code+(n.reason?": "+n.reason:"");e.onConnectionReset(t)},l.onmessage=n=>{e.onMessage(new Uint8Array(n.data))},{reset:()=>{l.onopen=null,l.onclose=null,l.onmessage=null,l.onerror=null,l.close()},send:e=>{l.send(e),0==c.quenedUnreportedBytes&&(c.nextTimeout=10,setTimeout(d,10)),c.quenedUnreportedBytes+=e.length},closeSend:()=>{throw new Error("Wrong connection type")},openOutSubstream:()=>{throw new Error("Wrong connection type")}}}if(null!=c){const n=c[3];if(a||"0"===n)throw new s.hY("Connection type not allowed");const t="ip4"==c[1]?"4":"6",o=c[2],i=c[4],u=(0,r.wV)(i),f=d(u);let p;const h=new Map;let m,w;const b=()=>{if(!p)return console.assert(0===h.size&&!m,"substreams exist while pc is undef"),void(p=null);p.onconnectionstatechange=null,p.onnegotiationneeded=null,p.ondatachannel=null;for(const e of Array.from(h.values()))e.channel.onopen=null,e.channel.onerror=null,e.channel.onclose=null,e.channel.onbufferedamountlow=null,e.channel.onmessage=null;h.clear(),m&&(m.onopen=null,m.onerror=null,m.onclose=null,m.onbufferedamountlow=null,m.onmessage=null),m=void 0,p.close()},y=(n,t)=>{const o=n.id;n.binaryType="arraybuffer";let s=!1;n.onopen=()=>{console.assert(!s,"substream opened twice"),s=!0,"first-outbound"===t?(console.assert(0===h.size,"dataChannels not empty when opening"),console.assert(m===n,"handshake substream mismatch"),e.onOpen({type:"multi-stream",handshake:"webrtc",localTlsCertificateMultihash:w,remoteTlsCertificateMultihash:u})):(console.assert("outbound"!==t||!m,"handshakeDataChannel still defined"),e.onStreamOpened(o,t,65536))},n.onerror=n.onclose=t=>{m!==n||s?m===n?(m.onopen=null,m.onerror=null,m.onclose=null,m.onbufferedamountlow=null,m.onmessage=null,m=void 0):s?e.onStreamReset(o):(b(),e.onConnectionReset("data channel failed to open")):(b(),e.onConnectionReset("handshake data channel failed to open"))},n.onbufferedamountlow=()=>{const n=h.get(o),t=n.bufferedBytes;n.bufferedBytes=0,e.onWritableBytes(t,o)},n.onmessage=n=>{e.onMessage(new Uint8Array(n.data),o)},"first-outbound"!==t?h.set(o,{channel:n,bufferedBytes:0}):m=n};return RTCPeerConnection.generateCertificate({name:"ECDSA",namedCurve:"P-256",hash:"SHA-256"}).then((s=>l(this,void 0,void 0,(function*(){if(null===p)return;let r;if(p=new RTCPeerConnection({certificates:[s]}),s.getFingerprints){for(const{algorithm:e,value:n}of s.getFingerprints())if("sha-256"===e){r=n;break}}else{const e=(yield p.createOffer()).sdp.match(/a(\s*)=(\s*)fingerprint:(\s*)(sha|SHA)-256(\s*)(([a-fA-F0-9]{2}(:)*){32})/);e&&(r=e[6])}void 0!==r?(w=new Uint8Array(34),w.set([18,32],0),w.set(r.split(":").map((e=>parseInt(e,16))),2),p.onconnectionstatechange=n=>{"closed"!=p.connectionState&&"disconnected"!=p.connectionState&&"failed"!=p.connectionState||(b(),e.onConnectionReset("WebRTC state transitioned to "+p.connectionState))},p.onnegotiationneeded=e=>l(this,void 0,void 0,(function*(){var e;let s=(yield p.createOffer()).sdp;null===s.match(/^m=application(\s+)(\d+)(\s+)UDP\/DTLS\/SCTP(\s+)webrtc-datachannel$/m)&&console.error("Local offer doesn't contain UDP data channel. WebRTC connections will likely fail. Please report this issue.");const r=null===(e=s.match(/^a=ice-pwd:(.+)$/m))||void 0===e?void 0:e.at(1);void 0===r&&console.error("Failed to set ufrag to pwd. WebRTC connections will likely fail. Please report this issue.");const a="libp2p+webrtc+v1/"+r;s=s.replace(/^a=ice-ufrag.*$/m,"a=ice-ufrag:"+a),s=s.replace(/^a=ice-pwd.*$/m,"a=ice-pwd:"+a),yield p.setLocalDescription({type:"offer",sdp:s});const i=Array.from(f).map((e=>("0"+e.toString(16)).slice(-2).toUpperCase())).join(":"),l="v=0\no=- 0 0 IN IP"+t+" "+o+"\ns=-\nt=0 0\na=ice-lite\nm=application "+n+" UDP/DTLS/SCTP webrtc-datachannel\nc=IN IP"+t+" "+o+"\na=mid:0\na=ice-options:ice2\na=ice-ufrag:"+a+"\na=ice-pwd:"+a+"\na=fingerprint:sha-256 "+i+"\na=setup:passive\na=sctp-port:5000\na=max-message-size:16384\na=candidate:1 1 UDP 1 "+o+" "+n+" typ host\n";yield p.setRemoteDescription({type:"answer",sdp:l})})),p.ondatachannel=({channel:e})=>{y(e,"inbound")},y(p.createDataChannel("",{id:0,negotiated:!0}),"first-outbound")):e.onConnectionReset("Failed to obtain the browser certificate fingerprint")})))),{reset:e=>{if(void 0===e)b();else{const n=h.get(e);n.channel.onopen=null,n.channel.onerror=null,n.channel.onclose=null,n.channel.onbufferedamountlow=null,n.channel.onmessage=null,n.channel.close(),h.delete(e)}},send:(e,n)=>{const t=h.get(n);t.channel.send(e),t.bufferedBytes+=e.length},closeSend:()=>{throw new Error("Wrong connection type")},openOutSubstream:()=>{m?(()=>{l(this,void 0,void 0,(function*(){m&&(e.onStreamOpened(m.id,"outbound",1048576),h.set(m.id,{channel:m,bufferedBytes:0}),m=void 0)}))})():y(p.createDataChannel(""),"outbound")}}}throw new s.hY("Unrecognized multiaddr format")}(n,(null==e?void 0:e.forbidWs)||!1,(null==e?void 0:e.forbidNonLocalWs)||!1,(null==e?void 0:e.forbidWss)||!1,(null==e?void 0:e.forbidWebRtc)||!1)})}const d=e=>{if(34!=e.length||18!=e[0]||32!=e[1])throw new Error("Certificate multihash is not SHA-256");return new Uint8Array(e.slice(2))}}}]);