"use strict";(("undefined"!=typeof self?self:this).webpackChunk_polkadot_apps=("undefined"!=typeof self?self:this).webpackChunk_polkadot_apps||[]).push([[5512],{9954:(e,r,n)=>{n.d(r,{hY:()=>t.h,LX:()=>u,Ps:()=>h,t_:()=>f,BL:()=>d});var o=n(33323),t=n(48095),s=n(40767),i=n(62702),c=function(e,r,n,o){return new(n||(n=Promise))((function(t,s){function i(e){try{a(o.next(e))}catch(e){s(e)}}function c(e){try{a(o.throw(e))}catch(e){s(e)}}function a(e){var r;e.done?t(e.value):(r=e.value,r instanceof n?r:new n((function(e){e(r)}))).then(i,c)}a((o=o.apply(e,r||[])).next())}))};function a(e,r){return c(this,void 0,void 0,(function*(){const n=yield r.trustedBase64DecodeAndZlibInflate(i.Z);let o;const c=Object.assign({performanceNow:r.performanceNow,connect:r.connect,onPanic:r=>{throw o(),e.onWasmPanic(r),new Error}},e),a={envVars:[],getRandomValues:r.getRandomValues,onProcExit:r=>{throw o(),e.onWasmPanic(`proc_exit called: ${r}`),new Error}},{imports:l,killAll:p}=(0,t.Z)(c);o=p;const u=(yield WebAssembly.instantiate(n,{smoldot:l,wasi_snapshot_preview1:(0,s.Z)(a)})).instance;return c.instance=u,a.instance=u,u}))}var l=n(36753),p=function(e,r,n,o){return new(n||(n=Promise))((function(t,s){function i(e){try{a(o.next(e))}catch(e){s(e)}}function c(e){try{a(o.throw(e))}catch(e){s(e)}}function a(e){var r;e.done?t(e.value):(r=e.value,r instanceof n?r:new n((function(e){e(r)}))).then(i,c)}a((o=o.apply(e,r||[])).next())}))};class u extends Error{constructor(e){super(e)}}class h extends Error{constructor(){super("JSON-RPC request is malformed")}}class f extends Error{constructor(){super("JSON-RPC requests queue is full")}}function d(e,r){let n;const t={},s={name:null},i={printError:!0};let c=new Map;const d={onWasmPanic:e=>{if(t.error=new u(e),i.printError){console.error("Smoldot has panicked"+(s.name?" while executing task `"+s.name+"`":"")+". This is a bug in smoldot. Please open an issue at https://github.com/smol-dot/smoldot/issues with the following message:\n"+e);for(const e of Array.from(c.values())){for(const r of e.jsonRpcResponsesPromises)r.reject(t.error);e.jsonRpcResponsesPromises=[]}}},logCallback:(r,n,o)=>{e.logCallback(r,n,o)},jsonRpcResponsesNonEmptyCallback:e=>{const r=c.get(e).jsonRpcResponsesPromises;for(;0!==r.length;)r.shift().resolve()},currentTaskCallback:e=>{s.name=e},cpuRateLimit:e.cpuRateLimit};function m(e){return p(this,void 0,void 0,(function*(){return n.initialized?e(n.instance):n.promise.then((r=>e(r)))}))}return n={initialized:!1,promise:a(d,r).then((o=>{let s=Math.round(4294967295*d.cpuRateLimit);s<0&&(s=0),s>4294967295&&(s=4294967295),Number.isFinite(s)||(s=4294967295);const[i,c]=r.registerShouldPeriodicallyYield((e=>{if(n.initialized&&!t.error)try{n.instance.exports.set_periodically_yield(e?1:0)}catch(e){}}));return o.exports.init(e.maxLogLevel,e.enableCurrentTask?1:0,s,i?1:0),n={initialized:!0,instance:o,unregisterCallback:c},o}))},{request:(e,r)=>{if(!n.initialized)throw new Error("Internal error");if(t.error)throw t.error;let o;try{const t=(new TextEncoder).encode(e),s=n.instance.exports.alloc(t.length)>>>0;new Uint8Array(n.instance.exports.memory.buffer).set(t,s),o=n.instance.exports.json_rpc_send(s,t.length,r)>>>0}catch(e){throw console.assert(t.error),t.error}switch(o){case 0:break;case 1:throw new h;case 2:throw new f;default:throw new Error("Internal error: unknown json_rpc_send error code: "+o)}},nextJsonRpcResponse:e=>p(this,void 0,void 0,(function*(){if(!n.initialized)throw new Error("Internal error");for(;;){if(t.error)throw t.error;try{const r=new Uint8Array(n.instance.exports.memory.buffer),t=n.instance.exports.json_rpc_responses_peek(e)>>>0,s=o.nm(r,t)>>>0,i=o.nm(r,t+4)>>>0;if(0!==i){const t=o.yV(r,s,i);return n.instance.exports.json_rpc_responses_pop(e),t}}catch(e){throw console.assert(t.error),t.error}yield new Promise(((r,n)=>{c.get(e).jsonRpcResponsesPromises.push({resolve:()=>r(void 0),reject:n})}))}})),addChain:(e,r,n,s)=>m((i=>{if(t.error)throw t.error;try{const t=(new TextEncoder).encode(e),a=i.exports.alloc(t.length)>>>0;new Uint8Array(i.exports.memory.buffer).set(t,a);const l=(new TextEncoder).encode(r),p=i.exports.alloc(l.length)>>>0;new Uint8Array(i.exports.memory.buffer).set(l,p);const u=n.length,h=i.exports.alloc(4*u)>>>0;for(let e=0;e<n.length;++e)o.v7(new Uint8Array(i.exports.memory.buffer),h+4*e,n[e]);const f=i.exports.add_chain(a,t.length,p,l.length,s?0:1,h,u);if(0!=i.exports.chain_is_ok(f))return console.assert(!c.has(f)),c.set(f,{jsonRpcResponsesPromises:new Array}),{success:!0,chainId:f};{const e=i.exports.chain_error_len(f)>>>0,r=i.exports.chain_error_ptr(f)>>>0,n=o.yV(new Uint8Array(i.exports.memory.buffer),r,e);return i.exports.remove_chain(f),{success:!1,error:n}}}catch(e){throw console.assert(t.error),t.error}})),removeChain:e=>{if(!n.initialized)throw new Error("Internal error");if(t.error)throw t.error;console.assert(c.has(e));for(const{reject:r}of c.get(e).jsonRpcResponsesPromises)r(new l.A_);c.delete(e);try{n.instance.exports.remove_chain(e)}catch(e){throw console.assert(t.error),t.error}},startShutdown:()=>m((e=>{if(!t.error){n.initialized&&n.unregisterCallback();try{i.printError=!1,e.exports.start_shutdown()}catch(e){}}}))}}}}]);