"use strict";(("undefined"!=typeof self?self:this).webpackChunk_polkadot_apps=("undefined"!=typeof self?self:this).webpackChunk_polkadot_apps||[]).push([[5512],{9954:(e,r,n)=>{n.d(r,{hY:()=>t.h,LX:()=>p,Ps:()=>d,t_:()=>h,BL:()=>f});var o=n(33323),t=n(48095),s=n(40767),i=n(62702),c=function(e,r,n,o){return new(n||(n=Promise))((function(t,s){function i(e){try{a(o.next(e))}catch(e){s(e)}}function c(e){try{a(o.throw(e))}catch(e){s(e)}}function a(e){var r;e.done?t(e.value):(r=e.value,r instanceof n?r:new n((function(e){e(r)}))).then(i,c)}a((o=o.apply(e,r||[])).next())}))};function a(e,r){return c(this,void 0,void 0,(function*(){const n=yield r.trustedBase64DecodeAndZlibInflate(i.Z);let o;const c=new Array,a=Object.assign({bufferIndices:c,performanceNow:r.performanceNow,connect:r.connect,onPanic:r=>{throw o(),e.onWasmPanic(r),new Error}},e),l={envVars:[],getRandomValues:r.getRandomValues,onProcExit:r=>{throw o(),e.onWasmPanic(`proc_exit called: ${r}`),new Error}},{imports:u,killAll:p}=(0,t.Z)(a);o=p;const d=(yield WebAssembly.instantiate(n,{smoldot:u,wasi_snapshot_preview1:(0,s.Z)(l)})).instance;return a.instance=d,l.instance=d,[d,c]}))}var l=n(36753),u=function(e,r,n,o){return new(n||(n=Promise))((function(t,s){function i(e){try{a(o.next(e))}catch(e){s(e)}}function c(e){try{a(o.throw(e))}catch(e){s(e)}}function a(e){var r;e.done?t(e.value):(r=e.value,r instanceof n?r:new n((function(e){e(r)}))).then(i,c)}a((o=o.apply(e,r||[])).next())}))};class p extends Error{constructor(e){super(e)}}class d extends Error{constructor(){super("JSON-RPC request is malformed")}}class h extends Error{constructor(){super("JSON-RPC requests queue is full")}}function f(e,r){let n;const t={},s={name:null},i={printError:!0};let c=new Map;const f={onWasmPanic:e=>{if(t.error=new p(e),i.printError){console.error("Smoldot has panicked"+(s.name?" while executing task `"+s.name+"`":"")+". This is a bug in smoldot. Please open an issue at https://github.com/smol-dot/smoldot/issues with the following message:\n"+e);for(const e of Array.from(c.values())){for(const r of e.jsonRpcResponsesPromises)r.reject(t.error);e.jsonRpcResponsesPromises=[]}}},logCallback:(r,n,o)=>{e.logCallback(r,n,o)},jsonRpcResponsesNonEmptyCallback:e=>{const r=c.get(e).jsonRpcResponsesPromises;for(;0!==r.length;)r.shift().resolve()},currentTaskCallback:e=>{s.name=e},cpuRateLimit:e.cpuRateLimit};function w(e){return u(this,void 0,void 0,(function*(){return n.initialized?e(n.instance,n.bufferIndices):n.promise.then((([r,n])=>e(r,n)))}))}return n={initialized:!1,promise:a(f,r).then((([o,s])=>{let i=Math.round(4294967295*f.cpuRateLimit);i<0&&(i=0),i>4294967295&&(i=4294967295),Number.isFinite(i)||(i=4294967295);const[c,a]=r.registerShouldPeriodicallyYield((e=>{if(n.initialized&&!t.error)try{n.instance.exports.set_periodically_yield(e?1:0)}catch(e){}}));return o.exports.init(e.maxLogLevel,e.enableCurrentTask?1:0,i,c?1:0),n={initialized:!0,instance:o,bufferIndices:s,unregisterCallback:a},[o,s]}))},{request:(e,r)=>{if(!n.initialized)throw new Error("Internal error");if(t.error)throw t.error;let o;try{n.bufferIndices[0]=(new TextEncoder).encode(e),o=n.instance.exports.json_rpc_send(0,r)>>>0}catch(e){throw console.assert(t.error),t.error}switch(o){case 0:break;case 1:throw new d;case 2:throw new h;default:throw new Error("Internal error: unknown json_rpc_send error code: "+o)}},nextJsonRpcResponse:e=>u(this,void 0,void 0,(function*(){if(!n.initialized)throw new Error("Internal error");for(;;){if(t.error)throw t.error;try{const r=new Uint8Array(n.instance.exports.memory.buffer),t=n.instance.exports.json_rpc_responses_peek(e)>>>0,s=o.nm(r,t)>>>0,i=o.nm(r,t+4)>>>0;if(0!==i){const t=o.yV(r,s,i);return n.instance.exports.json_rpc_responses_pop(e),t}}catch(e){throw console.assert(t.error),t.error}yield new Promise(((r,n)=>{c.get(e).jsonRpcResponsesPromises.push({resolve:()=>r(void 0),reject:n})}))}})),addChain:(e,r,n,s)=>w(((i,a)=>{if(t.error)throw t.error;try{a[0]=(new TextEncoder).encode(e),a[1]=(new TextEncoder).encode(r);const t=new Uint8Array(4*n.length);for(let e=0;e<n.length;++e)o.v7(t,4*e,n[e]);a[2]=t;const l=i.exports.add_chain(0,1,s?0:1,2);if(delete a[0],delete a[1],delete a[2],0!=i.exports.chain_is_ok(l))return console.assert(!c.has(l)),c.set(l,{jsonRpcResponsesPromises:new Array}),{success:!0,chainId:l};{const e=i.exports.chain_error_len(l)>>>0,r=i.exports.chain_error_ptr(l)>>>0,n=o.yV(new Uint8Array(i.exports.memory.buffer),r,e);return i.exports.remove_chain(l),{success:!1,error:n}}}catch(e){throw console.assert(t.error),t.error}})),removeChain:e=>{if(!n.initialized)throw new Error("Internal error");if(t.error)throw t.error;console.assert(c.has(e));for(const{reject:r}of c.get(e).jsonRpcResponsesPromises)r(new l.A_);c.delete(e);try{n.instance.exports.remove_chain(e)}catch(e){throw console.assert(t.error),t.error}},startShutdown:()=>w((e=>{if(!t.error){n.initialized&&n.unregisterCallback();try{i.printError=!1,e.exports.start_shutdown()}catch(e){}}}))}}}}]);